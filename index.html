<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>SPLIT IT - J.T.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    @font-face {
      font-family: "Kremlin";
      src: url("fonts/Kremlin.woff") format("woff"),
        url("fonts/Kremlin.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-color: #ffffff;
      --text-color: #111111;
      --border-color: #000000;
      --shadow-color: #000000;

      --slice-width: 200px;
      --slice-height-outer: 20px;
      --slice-height-middle: 46px;

      --letter-size: 140px;
      --letter-baseline: 0px;

      /* KEY FIX: kleine overlap om “seams/randen” op mobiel weg te werken */
      --row-overlap: -1px;

      /* offsets (altijd hele pixels gezet via JS) */
      --top-offset: 0px;
      --middle-offset: 0px;
      --bottom-offset: 0px;
    }

    body.dark {
      --bg-color: #000000;
      --text-color: #f5f5f5;
      --border-color: #f5f5f5;
      --shadow-color: #f5f5f5;
    }

    /* iOS/Android address-bar layout jump fix + geen page shift */
    body {
      background: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Kremlin", sans-serif;
      overflow: hidden;
      touch-action: pan-y;
      /* page mag verticaal */
    }

    @supports (min-height: 100svh) {
      body {
        min-height: 100svh;
      }
    }

    .wrapper {
      width: 100%;
      max-width: 1000px;
    }

    .row-top,
    .row-middle,
    .row-bottom {
      display: block;
      margin: 0;
      padding: 0;
    }

    .strip {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      margin: 0;
      padding: 0;
      line-height: 0;
      background: var(--bg-color);
      -ms-overflow-style: none;
      scrollbar-width: none;
      touch-action: pan-x;
      /* strip mag horizontaal */
      overscroll-behavior-x: none;
    }

    .strip::-webkit-scrollbar {
      display: none;
    }

    /* overlap rows -> geen dunne lijntjes */
    .row-middle,
    .row-bottom {
      margin-top: var(--row-overlap);
    }

    .strip-inner {
      display: inline-flex;
      white-space: nowrap;
    }

    .slice {
      flex: 0 0 var(--slice-width);
      position: relative;
      overflow: hidden;
      display: block;
      contain: layout paint;
      /* minder “glitches” bij rebuild */
    }

    .row-top .slice,
    .row-bottom .slice {
      height: var(--slice-height-outer);
    }

    .row-middle .slice {
      height: var(--slice-height-middle);
    }

    .letter {
      font-size: var(--letter-size);
      line-height: 1;
      color: var(--text-color);
      font-weight: 600;

      position: absolute;
      left: 0;
      width: 100%;
      height: var(--letter-size);

      display: flex;
      justify-content: center;
      align-items: center;

      /* extra: minder “subpixel shimmer” */
      transform: translateZ(0);
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    .row-top .letter {
      top: calc(var(--letter-baseline) + var(--top-offset));
      z-index: 1;
    }

    .row-middle .letter {
      top: calc(var(--letter-baseline) - var(--slice-height-outer) - var(--row-overlap) + var(--middle-offset));
      z-index: 2;
    }

    .row-bottom .letter {
      top: calc(var(--letter-baseline) - var(--slice-height-outer) - var(--slice-height-middle) - (var(--row-overlap) * 2) + var(--bottom-offset));
      z-index: 3;
    }

    .strip,
    .strip-inner,
    .slice,
    .letter {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }

    @media (max-width:1024px) {
      .wrapper {
        max-width: 90vw;
      }
    }

    @media (max-width:640px) {
      .wrapper {
        max-width: 100vw;
      }
    }

    .word-input {
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: var(--bg-color);
      border: 2px solid var(--border-color);
      padding: 10px 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 14px;
      box-shadow: 6px 6px 0 var(--shadow-color);
      z-index: 99;
    }

    .word-input input {
      border: 2px solid var(--border-color);
      padding: 6px 8px;
      font-family: inherit;
      font-size: 14px;
      width: 150px;
      outline: none;
      background: var(--bg-color);
      color: var(--text-color);
    }

    .word-input input::placeholder {
      color: var(--text-color);
      opacity: 0.6;
    }

    .word-input button {
      border: 2px solid var(--border-color);
      background: var(--border-color);
      color: var(--bg-color);
      padding: 6px 10px;
      font-size: 13px;
    }

    .word-input button:hover {
      opacity: 0.85;
    }

    .dark-toggle {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border-color);
      background: var(--border-color);
      flex-shrink: 0;
    }

    .dark-toggle:hover {
      background: gray;
      border-color: gray;
    }
  </style>
</head>

<body>
  <div class="wrapper">
    <div class="strip row-top">
      <div class="strip-inner" id="topRow"></div>
    </div>
    <div class="strip row-middle">
      <div class="strip-inner" id="middleRow"></div>
    </div>
    <div class="strip row-bottom">
      <div class="strip-inner" id="bottomRow"></div>
    </div>
  </div>

  <div class="word-input">
    <input type="text" id="wordInput" placeholder="TYPE A WORD" />
    <button id="applyWord">SET</button>
    <div class="dark-toggle" id="darkToggle"></div>
  </div>

  <script>
    const topRow = document.getElementById("topRow");
    const middleRow = document.getElementById("middleRow");
    const bottomRow = document.getElementById("bottomRow");
    const input = document.getElementById("wordInput");
    const button = document.getElementById("applyWord");
    const darkToggle = document.getElementById("darkToggle");
    const strips = Array.from(document.querySelectorAll(".strip"));

    const REPEATS = 20;
    let currentWord = window.innerWidth <= 640 ? "HEY" : "HELL0";

    // state
    let isRebuilding = false;
    const stripStates = strips.map(strip => ({
      strip,
      patternWidth: 0,
      // drag state
      isDown: false,
      startX: 0,
      startScrollLeft: 0,
      // snap animation
      isAnimating: false,
      animationId: null,
      snapTimeout: null,
      pointerId: null
    }));

    function pxInt(n) { return Math.round(n); }

    function updateLayoutVariables() {
      const root = document.documentElement;
      const width = window.innerWidth;

      let fontSize;
      if (width <= 640) fontSize = pxInt(width * 0.20);
      else if (width <= 1024) fontSize = 120;
      else fontSize = 140;

      // heights: integer pixels (important)
      const sliceHeightOuter = pxInt(fontSize * 0.140);
      const sliceHeightMiddle = pxInt(fontSize * 0.330);

      // offsets: ALSO integer pixels (important)
      const topOffset = pxInt(fontSize * 0.045);
      const middleOffset = pxInt(fontSize * 0.018);
      const bottomOffset = pxInt(-fontSize * 0.015);

      // overlap: -1px kills seams on mobile
      const overlap = -1;

      // baseline: integer
      const totalHeight = sliceHeightOuter + sliceHeightMiddle + sliceHeightOuter;
      const baseline = pxInt((totalHeight - fontSize) / 2);

      root.style.setProperty("--letter-size", fontSize + "px");
      root.style.setProperty("--slice-height-outer", sliceHeightOuter + "px");
      root.style.setProperty("--slice-height-middle", sliceHeightMiddle + "px");
      root.style.setProperty("--letter-baseline", baseline + "px");
      root.style.setProperty("--row-overlap", overlap + "px");
      root.style.setProperty("--top-offset", topOffset + "px");
      root.style.setProperty("--middle-offset", middleOffset + "px");
      root.style.setProperty("--bottom-offset", bottomOffset + "px");

      // KEY FIX: op mobiel EXACT 3 letters zichtbaar door slice-width = stripWidth/3 (echte breedte)
      // op desktop/tablet vaste waarden
      if (width <= 640) {
        // neem breedte van wrapper/strip (niet innerWidth!)
        const stripWidth = strips[0].clientWidth || width;
        const sliceWidth = Math.floor(stripWidth / 3);
        root.style.setProperty("--slice-width", sliceWidth + "px");
      } else if (width <= 1024) {
        root.style.setProperty("--slice-width", "180px");
      } else {
        root.style.setProperty("--slice-width", "200px");
      }
    }

    function getSliceWidth() {
      return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--slice-width")) || 200;
    }

    function cancelSnap(state) {
      if (state.animationId !== null) {
        cancelAnimationFrame(state.animationId);
        state.animationId = null;
      }
      state.isAnimating = false;
      if (state.snapTimeout !== null) {
        clearTimeout(state.snapTimeout);
        state.snapTimeout = null;
      }
    }

    function animateToNearest(state) {
      if (isRebuilding) return;
      const strip = state.strip;
      const sliceW = getSliceWidth();
      const current = strip.scrollLeft;

      const index = Math.round(current / sliceW);
      const target = index * sliceW;

      const dist = target - current;
      if (Math.abs(dist) < 0.5) return;

      cancelSnap(state);
      state.isAnimating = true;

      const start = performance.now();
      const duration = 260;
      const from = current;

      function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      }

      function frame(now) {
        if (isRebuilding) { cancelSnap(state); return; }
        const t = Math.min((now - start) / duration, 1);
        const eased = easeInOutQuad(t);
        strip.scrollLeft = from + (target - from) * eased;

        if (t < 1) {
          state.animationId = requestAnimationFrame(frame);
        } else {
          state.animationId = null;
          state.isAnimating = false;
        }
      }
      state.animationId = requestAnimationFrame(frame);
    }

    function scheduleSnap(state) {
      if (isRebuilding) return;
      if (state.isAnimating) return;
      if (state.snapTimeout !== null) clearTimeout(state.snapTimeout);
      state.snapTimeout = setTimeout(() => {
        if (!state.isDown) animateToNearest(state);
      }, 120);
    }

    function updatePatternWidths(word) {
      const sliceW = getSliceWidth();
      const lettersPerPattern = Math.max(1, word.length);
      const patternW = lettersPerPattern * sliceW;

      stripStates.forEach(st => st.patternWidth = patternW);
    }

    function jumpToMiddle() {
      // zet alle strips naar “midden patroon” om infinite scroll stabiel te maken
      const sliceW = getSliceWidth();
      const lettersPerPattern = Math.max(1, currentWord.length);
      const patternW = lettersPerPattern * sliceW;

      const middleRepeat = Math.floor(REPEATS / 2);
      const startOfMiddlePattern = middleRepeat * patternW;

      stripStates.forEach(st => {
        st.strip.scrollLeft = startOfMiddlePattern;
      });
    }

    function buildRows(word) {
      const letters = (word || "").toUpperCase().split("");
      const safe = letters.length ? letters : ["A"];

      topRow.innerHTML = "";
      middleRow.innerHTML = "";
      bottomRow.innerHTML = "";

      // Bouw eerst een DocumentFragment (minder layout thrash/glitch)
      const fragTop = document.createDocumentFragment();
      const fragMid = document.createDocumentFragment();
      const fragBot = document.createDocumentFragment();

      for (let r = 0; r < REPEATS; r++) {
        for (let i = 0; i < safe.length; i++) {
          const char = safe[i];

          const slice = document.createElement("div");
          slice.className = "slice";
          slice.innerHTML = "<div class='letter'>" + char + "</div>";

          fragTop.appendChild(slice);
          fragMid.appendChild(slice.cloneNode(true));
          fragBot.appendChild(slice.cloneNode(true));
        }
      }

      topRow.appendChild(fragTop);
      middleRow.appendChild(fragMid);
      bottomRow.appendChild(fragBot);

      updatePatternWidths(safe.join(""));

      // Wacht 2 frames voor layout/styling klaar is -> voorkomt “glitch”
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          jumpToMiddle();
        });
      });
    }

    function safeRebuild(newWord) {
      isRebuilding = true;

      // stop alle animaties/timers
      stripStates.forEach(st => cancelSnap(st));

      // layout vars eerst (sliceWidth kan veranderen op mobiel)
      updateLayoutVariables();

      // rebuild
      currentWord = newWord;
      buildRows(currentWord);

      // rebuild done (na layout)
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          isRebuilding = false;
        });
      });
    }

    function setWordFromInput() {
      const raw = input.value.trim();
      const value = (raw || currentWord).toUpperCase();
      safeRebuild(value);
    }

    // infinite scroll (stabieler met guard)
    function attachInfiniteScroll() {
      stripStates.forEach(st => {
        st.strip.addEventListener("scroll", () => {
          if (isRebuilding) return;

          const pw = st.patternWidth;
          if (!pw) return;

          const s = st.strip.scrollLeft;
          const min = pw * 2;
          const max = pw * (REPEATS - 2);

          if (s < min) {
            st.strip.scrollLeft = s + pw * (REPEATS - 4);
          } else if (s > max) {
            st.strip.scrollLeft = s - pw * (REPEATS - 4);
          }

          if (!st.isDown && !st.isAnimating) scheduleSnap(st);
        }, { passive: true });
      });
    }

    // drag + snap via Pointer Events (touch + mouse)
    function attachDragAndSnap() {
      stripStates.forEach(st => {
        const strip = st.strip;

        strip.addEventListener("pointerdown", (e) => {
          if (isRebuilding) return;
          // alleen primary pointer
          st.isDown = true;
          st.pointerId = e.pointerId;
          strip.setPointerCapture(e.pointerId);

          st.startX = e.clientX;
          st.startScrollLeft = strip.scrollLeft;

          cancelSnap(st);
          e.preventDefault();
        });

        strip.addEventListener("pointermove", (e) => {
          if (!st.isDown) return;
          if (isRebuilding) return;
          if (st.pointerId !== e.pointerId) return;

          const dx = e.clientX - st.startX;
          strip.scrollLeft = st.startScrollLeft - dx;
          e.preventDefault();
        });

        function endDrag(e) {
          if (!st.isDown) return;
          if (st.pointerId !== null && e && st.pointerId !== e.pointerId) return;

          st.isDown = false;
          st.pointerId = null;
          scheduleSnap(st);
        }

        strip.addEventListener("pointerup", endDrag);
        strip.addEventListener("pointercancel", endDrag);
        strip.addEventListener("lostpointercapture", () => {
          if (!st.isDown) return;
          st.isDown = false;
          st.pointerId = null;
          scheduleSnap(st);
        });
      });
    }

    // theme
    darkToggle.addEventListener("click", () => {
      document.body.classList.toggle("dark");
    });

    // input filter (A-Z + 0-9)
    input.addEventListener("input", () => {
      input.value = input.value.toUpperCase().replace(/[^A-Z0-9]/g, "");
    });

    button.addEventListener("click", setWordFromInput);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") setWordFromInput();
    });

    // resize: opnieuw variables + rebuild (stabiel, zonder glitch)
    let resizeT = null;
    window.addEventListener("resize", () => {
      if (resizeT) clearTimeout(resizeT);
      resizeT = setTimeout(() => {
        // keep word, rebuild to enforce exact 3 letters on mobile + no seams
        safeRebuild(currentWord);
      }, 120);
    }, { passive: true });

    // INIT
    updateLayoutVariables();
    buildRows(currentWord);
    attachInfiniteScroll();
    attachDragAndSnap();
  </script>
</body>

</html>
